import { Artifact, Name } from '../../model';
import { Ability, AbilityType, Answerable } from '../../screenplay';
import { Stage } from '../../stage';
import { Activity } from '../Activity';
import { AnswersQuestions } from './AnswersQuestions';
import { CanHaveAbilities } from './CanHaveAbilities';
import { CollectsArtifacts } from './CollectsArtifacts';
import { PerformsActivities } from './PerformsActivities';
import { UsesAbilities } from './UsesAbilities';
/**
 * Core element of the Screenplay Pattern,
 * an {@apilink Actor} represents a user or an external system interacting with the system under test.
 *
 * ## Learn more
 *
 * - {@apilink Cast}
 * - {@apilink Stage}
 *
 * @group Actors
 */
export declare class Actor implements PerformsActivities, UsesAbilities, CanHaveAbilities<Actor>, AnswersQuestions, CollectsArtifacts {
    readonly name: string;
    private readonly stage;
    private readonly abilities;
    constructor(name: string, stage: Stage, abilities?: Map<AbilityType<Ability>, Ability>);
    /**
     * Retrieves actor's {@apilink Ability} of `abilityType`, or one that extends `abilityType`.
     *
     * Please note that this method performs an {@apilink instanceof} check against abilities
     * given to this actor via {@apilink Actor.whoCan}.
     *
     * Please also note that {@apilink Actor.whoCan} performs the same check when abilities are assigned to the actor
     * to ensure the actor has at most one instance of a given ability type.
     *
     * @param abilityType
     */
    abilityTo<T extends Ability>(abilityType: AbilityType<T>): T;
    /**
     * Instructs the actor to attempt to perform a number of {@apilink Activity|activities},
     * so either {@apilink Task|Tasks} or {@apilink Interaction|Interactions}),
     * one by one.
     *
     * @param {...activities: Activity[]} activities
     */
    attemptsTo(...activities: Activity[]): Promise<void>;
    /**
     * Gives this Actor a list of {@apilink Ability|abilities} they can use
     * to interact with the system under test or the test environment.
     *
     * @param abilities
     *  A vararg list of abilities to give the actor
     *
     * @returns
     *  The actor with newly gained abilities
     *
     * @throws {@apilink ConfigurationError}
     *  Throws a ConfigurationError if the actor already has an ability of this type.
     */
    whoCan(...abilities: Ability[]): Actor;
    /**
     * @param answerable -
     *  An {@apilink Answerable} to answer (resolve the value of).
     *
     * @returns
     *  The answer to the Answerable
     */
    answer<T>(answerable: Answerable<T>): Promise<T>;
    /**
     * Announce collection of an {@apilink Artifact} so that it can be picked up by a {@apilink StageCrewMember}.
     *
     * @param artifact
     * @param name
     */
    collect(artifact: Artifact, name?: string | Name): void;
    /**
     * Instructs the actor to invoke {@apilink Discardable.discard} method on any
     * {@apilink Discardable} {@apilink Ability} it's been configured with.
     */
    dismiss(): Promise<void>;
    /**
     * Returns a human-readable, string representation of this actor and their abilities.
     *
     * **PRO TIP:** To get the name of the actor, use {@apilink Actor.name}
     */
    toString(): string;
    private initialiseAbilities;
    private findAbilitiesOfType;
    private findAbilityTo;
    /**
     * Instantiates a {@apilink Name} based on the string value of the parameter,
     * or returns the argument if it's already an instance of {@apilink Name}.
     *
     * @param maybeName
     */
    private nameFrom;
}
//# sourceMappingURL=Actor.d.ts.map