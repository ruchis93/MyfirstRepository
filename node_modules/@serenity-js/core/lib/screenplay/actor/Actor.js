"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actor = void 0;
const errors_1 = require("../../errors");
const events_1 = require("../../events");
const model_1 = require("../../model");
const activities_1 = require("../activities");
const Question_1 = require("../Question");
/**
 * Core element of the Screenplay Pattern,
 * an {@apilink Actor} represents a user or an external system interacting with the system under test.
 *
 * ## Learn more
 *
 * - {@apilink Cast}
 * - {@apilink Stage}
 *
 * @group Actors
 */
class Actor {
    // todo: Actor should have execution strategies
    // todo: the default one executes every activity
    // todo: there could be a dry-run mode that default to skip strategy
    constructor(name, stage, abilities = new Map()) {
        this.name = name;
        this.stage = stage;
        this.abilities = abilities;
    }
    /**
     * Retrieves actor's {@apilink Ability} of `abilityType`, or one that extends `abilityType`.
     *
     * Please note that this method performs an {@apilink instanceof} check against abilities
     * given to this actor via {@apilink Actor.whoCan}.
     *
     * Please also note that {@apilink Actor.whoCan} performs the same check when abilities are assigned to the actor
     * to ensure the actor has at most one instance of a given ability type.
     *
     * @param abilityType
     */
    abilityTo(abilityType) {
        const found = this.findAbilityTo(abilityType);
        if (!found) {
            if (this.abilities.size > 0) {
                throw new errors_1.ConfigurationError(`${this.name} can ${Array.from(this.abilities.keys()).map(type => type.name).join(', ')}. ` +
                    `They can't, however, ${abilityType.name} yet. ` +
                    `Did you give them the ability to do so?`);
            }
            throw new errors_1.ConfigurationError(`${this.name} can't ${abilityType.name} yet. ` +
                `Did you give them the ability to do so?`);
        }
        return found;
    }
    /**
     * Instructs the actor to attempt to perform a number of {@apilink Activity|activities},
     * so either {@apilink Task|Tasks} or {@apilink Interaction|Interactions}),
     * one by one.
     *
     * @param {...activities: Activity[]} activities
     */
    attemptsTo(...activities) {
        return activities
            .map(activity => new activities_1.TrackedActivity(activity, this.stage))
            .reduce((previous, current) => {
            return previous
                // synchronise async operations like taking screenshots
                .then(() => this.stage.waitForNextCue())
                .then(() => {
                /* todo: add an execution strategy */
                return current.performAs(this);
            });
        }, this.initialiseAbilities());
    }
    /**
     * Gives this Actor a list of {@apilink Ability|abilities} they can use
     * to interact with the system under test or the test environment.
     *
     * @param abilities
     *  A vararg list of abilities to give the actor
     *
     * @returns
     *  The actor with newly gained abilities
     *
     * @throws {@apilink ConfigurationError}
     *  Throws a ConfigurationError if the actor already has an ability of this type.
     */
    whoCan(...abilities) {
        abilities.forEach(ability => {
            const abilityType = ability.constructor;
            const found = this.findAbilityTo(abilityType);
            if (found) {
                const description = found.constructor.name === abilityType.name
                    ? found.constructor.name
                    : `${found.constructor.name} (which extends ${abilityType.name})`;
                throw new errors_1.ConfigurationError(`${this.name} already has an ability to ${description}, so you don't need to give it to them again.`);
            }
            this.abilities.set(ability.constructor, ability);
        });
        return this;
    }
    /**
     * @param answerable -
     *  An {@apilink Answerable} to answer (resolve the value of).
     *
     * @returns
     *  The answer to the Answerable
     */
    answer(answerable) {
        function isAPromise(v) {
            return Object.prototype.hasOwnProperty.call(v, 'then');
        }
        function isDefined(v) {
            return !(v === undefined || v === null);
        }
        if (isDefined(answerable) && isAPromise(answerable)) {
            return answerable;
        }
        if (isDefined(answerable) && Question_1.Question.isAQuestion(answerable)) {
            return this.answer(answerable.answeredBy(this));
        }
        return Promise.resolve(answerable);
    }
    /**
     * Announce collection of an {@apilink Artifact} so that it can be picked up by a {@apilink StageCrewMember}.
     *
     * @param artifact
     * @param name
     */
    collect(artifact, name) {
        this.stage.announce(new events_1.ActivityRelatedArtifactGenerated(this.stage.currentSceneId(), this.stage.currentActivityId(), this.nameFrom(name || new model_1.Name(artifact.constructor.name)), artifact, this.stage.currentTime()));
    }
    /**
     * Instructs the actor to invoke {@apilink Discardable.discard} method on any
     * {@apilink Discardable} {@apilink Ability} it's been configured with.
     */
    dismiss() {
        return this.findAbilitiesOfType('discard')
            .reduce((previous, ability) => previous.then(() => ability.discard()), Promise.resolve(void 0));
    }
    /**
     * Returns a human-readable, string representation of this actor and their abilities.
     *
     * **PRO TIP:** To get the name of the actor, use {@apilink Actor.name}
     */
    toString() {
        const abilities = Array.from(this.abilities.keys()).map(type => type.name);
        return `Actor(name=${this.name}, abilities=[${abilities.join(', ')}])`;
    }
    initialiseAbilities() {
        return this.findAbilitiesOfType('initialise', 'isInitialised')
            .filter(ability => !ability.isInitialised())
            .reduce((previous, ability) => previous
            .then(() => ability.initialise())
            .catch(error => {
            throw new errors_1.TestCompromisedError(`${this.name} couldn't initialise the ability to ${ability.constructor.name}`, error);
        }), Promise.resolve(void 0));
    }
    findAbilitiesOfType(...methodNames) {
        const abilitiesFrom = (map) => Array.from(map.values());
        const abilitiesWithDesiredMethods = (ability) => methodNames.every(methodName => typeof (ability[methodName]) === 'function');
        return abilitiesFrom(this.abilities)
            .filter(abilitiesWithDesiredMethods);
    }
    findAbilityTo(doSomething) {
        for (const [abilityType_, ability] of this.abilities) {
            if (ability instanceof doSomething) {
                return ability;
            }
        }
        return undefined;
    }
    /**
     * Instantiates a {@apilink Name} based on the string value of the parameter,
     * or returns the argument if it's already an instance of {@apilink Name}.
     *
     * @param maybeName
     */
    nameFrom(maybeName) {
        return typeof maybeName === 'string'
            ? new model_1.Name(maybeName)
            : maybeName;
    }
}
exports.Actor = Actor;
//# sourceMappingURL=Actor.js.map