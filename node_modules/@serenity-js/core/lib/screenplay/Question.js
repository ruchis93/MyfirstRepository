"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Question = void 0;
const objects_1 = require("tiny-types/lib/objects");
const errors_1 = require("../errors");
const io_1 = require("../io");
const Interaction_1 = require("./Interaction");
/**
 * Serenity/JS Screenplay Pattern `Question` describes how an {@apilink Actor}
 * should query the system under test or the test environment.
 *
 * ## Implementing a basic custom Question
 *
 * ```ts
 *  import { actorCalled, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { Ensure, equals } from '@serenity-js/assertions'
 *
 *  const LastItemOf = <T>(list: T[]): Question<T> =>
 *    Question.about('last item from the list', (actor: AnswersQuestions & UsesAbilities) => {
 *      return list[list.length - 1]
 *    });
 *
 *  await actorCalled('Quentin').attemptsTo(
 *    Ensure.that(LastItemFrom([1,2,3]), equals(3)),
 *  )
 * ```
 *
 * ## Implementing a Question using an Ability
 *
 * Just like the {@apilink Interaction|interactions}, a {@apilink Question}
 * also can use {@apilink Actor|actor's} {@apilink Ability|abilities}.
 *
 * Here, we use the ability to {@apilink CallAnApi} to retrieve a property of
 * an HTTP response.
 *
 * ```ts
 *  import { AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi } from '@serenity-js/rest'
 *
 *  const TextOfLastResponseStatus = () =>
 *    Question.about<number>(`the text of the last response status`, actor => {
 *      return CallAnApi.as(actor).mapLastResponse(response => response.statusText)
 *    })
 * ```
 *
 * #### Learn more
 * - {@apilink CallAnApi}
 * - {@apilink LastResponse}
 *
 * ## Mapping answers to other questions
 *
 * Apart from retrieving information, {@apilink Question|questions} can be used to transform information retrieved by other questions.
 *
 * Here, we use the factory method {@apilink Question.about} to produce a question that makes the received {@apilink Actor|actor}
 * answer {@apilink LastResponse.status} and then compare it against some expected value.
 *
 * ```ts
 * import { actorCalled, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 * import { CallAnApi, LastResponse } from '@serenity-js/rest'
 * import { Ensure, equals } from '@serenity-js/assertions'
 *
 * const RequestWasSuccessful = () =>
 *   Question.about<number>(`the text of the last response status`, actor => {
 *     return LastResponse.status().answeredBy(actor) === 200;
 *   });
 *
 * await actorCalled('Quentin')
 *   .whoCan(CallAnApi.at('https://api.example.org/'));
 *   .attemptsTo(
 *     Send.a(GetRequest.to('/books/0-688-00230-7')),
 *     Ensure.that(RequestWasSuccessful(), isTrue()),
 *   );
 * ```
 *
 * Note that the above example is for demonstration purposes only, Serenity/JS provides an easier way to
 * verify the response status of the {@apilink LastResponse}:
 *
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { CallAnApi, LastResponse } from '@serenity-js/rest'
 * import { Ensure, equals } from '@serenity-js/assertions'
 *
 * await actorCalled('Quentin')
 *   .whoCan(CallAnApi.at('https://api.example.org/'));
 *   .attemptsTo(
 *     Send.a(GetRequest.to('/books/0-688-00230-7')),
 *     Ensure.that(LastResponse.status(), equals(200)),
 *   );
 * ```
 *
 * ## Learn more
 *
 * - {@apilink Actor}
 * - {@apilink Interaction}
 * - {@apilink Ability}
 * - {@apilink QuestionAdapter}
 *
 * @group Questions
 */
class Question {
    /**
     * Factory method that simplifies the process of defining custom questions.
     *
     * #### Defining a custom question
     *
     * ```ts
     * import { Question } from '@serenity-js/core'
     *
     * const EnvVariable = (name: string) =>
     *   Question.about(`the ${ name } env variable`, actor => process.env[name])
     * ```
     *
     * @param description
     * @param body
     */
    static about(description, body) {
        return Question.createAdapter(new QuestionStatement(description, body));
    }
    /**
     * Generates a {@apilink QuestionAdapter} that recursively resolves
     * any {@apilink Answerable} fields of the provided object,
     * including {@apilink Answerable} fields of {@apilink WithAnswerableProperties|nested objects}.
     *
     * Optionally, the method accepts `overrides` to be shallow-merged with the fields of the original `source`,
     * producing a new merged object.
     *
     * Overrides are applied from left to right, with subsequent objects overwriting property assignments of the previous ones.
     *
     * #### Resolving an object recursively using `Question.fromObject`
     *
     * ```ts
     * import { actorCalled, Question } from '@serenity-js/core'
     * import { Send, PostRequest } from '@serenity-js/rest'
     * import { By, Text, PageElement } from '@serenity-js/web'
     *
     * await actorCalled('Daisy')
     *   .whoCan(CallAnApi.at('https://api.example.org'))
     *   .attemptsTo(
     *     Send.a(
     *       PostRequest.to('/products/2')
     *         .with(
     *           Question.fromObject({
     *             name: Text.of(PageElement.located(By.css('.name'))),
     *           })
     *         )
     *       )
     *   );
     * ```
     *
     * #### Merging objects using `Question.fromObject`
     *
     * ```ts
     *  import { actorCalled, Question } from '@serenity-js/core'
     *  import { Send, PostRequest } from '@serenity-js/rest'
     *  import { By, Text, PageElement } from '@serenity-js/web'
     *
     *  await actorCalled('Daisy')
     *    .whoCan(CallAnApi.at('https://api.example.org'))
     *    .attemptsTo(
     *      Send.a(
     *        PostRequest.to('/products/2')
     *          .with(
     *            Question.fromObject({
     *              name: Text.of(PageElement.located(By.css('.name'))),
     *              quantity: undefined,
     *            }, {
     *              quantity: 2,
     *            })
     *          )
     *        )
     *    );
     *
     * @param source
     * @param overrides
     *
     * #### Learn more
     * - {@apilink WithAnswerableProperties}
     * - {@apilink RecursivelyAnswered}
     * - {@apilink Answerable}
     */
    static fromObject(source, ...overrides) {
        return Question.about('value', async (actor) => {
            if (source === null || source === undefined) {
                return source;
            }
            const sources = [];
            for (const [i, currentSource] of [source, ...overrides].entries()) {
                sources.push(await recursivelyAnswer(actor, currentSource, `argument ${i}`));
            }
            return Object.assign({}, ...sources);
        });
    }
    /**
     * Checks if the value is a {@apilink Question}.
     *
     * @param maybeQuestion
     *  The value to check
     */
    static isAQuestion(maybeQuestion) {
        return !!maybeQuestion
            && typeof maybeQuestion.answeredBy === 'function';
    }
    static createAdapter(statement) {
        return new Proxy(() => statement, {
            get(currentStatement, key, receiver) {
                const target = currentStatement();
                if (key === Symbol.toPrimitive) {
                    return (_hint) => {
                        return target.toString();
                    };
                }
                if (key in target) {
                    const field = Reflect.get(target, key);
                    const isFunction = typeof field == 'function';
                    const mustAllowProxyChaining = isFunction
                        && target instanceof QuestionStatement
                        && key === 'describedAs'; // `describedAs` returns `this`, which must be bound to proxy itself to allow proxy chaining
                    if (mustAllowProxyChaining) {
                        // see https://javascript.info/proxy#proxy-limitations
                        return field.bind(receiver);
                    }
                    return isFunction
                        ? field.bind(target)
                        : field;
                }
                if (key === 'then') {
                    return;
                }
                return Question.about(Question.fieldDescription(target, key), async (actor) => {
                    const answer = await actor.answer(target);
                    if (!isDefined(answer)) {
                        return undefined; // eslint-disable-line unicorn/no-useless-undefined
                    }
                    const field = answer[key];
                    return typeof field === 'function'
                        ? field.bind(answer)
                        : field;
                });
            },
            set(currentStatement, key, value, receiver) {
                const target = currentStatement();
                return Reflect.set(target, key, value);
            },
            apply(currentStatement, _thisArgument, parameters) {
                const target = currentStatement();
                return Question.about(Question.methodDescription(target, parameters), async (actor) => {
                    const params = [];
                    for (const parameter of parameters) {
                        const answered = await actor.answer(parameter);
                        params.push(answered);
                    }
                    const field = await actor.answer(target);
                    return typeof field === 'function'
                        ? field(...params)
                        : field;
                });
            },
            getPrototypeOf(currentStatement) {
                return Reflect.getPrototypeOf(currentStatement());
            },
        });
    }
    static fieldDescription(target, key) {
        // "of" is characteristic of Serenity/JS MetaQuestion
        if (key === 'of') {
            return `${target} ${key}`;
        }
        const originalSubject = (0, io_1.f) `${target}`;
        const fieldDescription = (typeof key === 'number' || /^\d+$/.test(String(key)))
            ? `[${String(key)}]` // array index
            : `.${String(key)}`; // field/method name
        return `${originalSubject}${fieldDescription}`;
    }
    static methodDescription(target, parameters) {
        const targetDescription = target.toString();
        // this is a Serenity/JS MetaQuestion, of(singleParameter)
        if (targetDescription.endsWith(' of') && parameters.length === 1) {
            return `${targetDescription} ${parameters[0]}`;
        }
        const parameterDescriptions = [
            '(', parameters.map(p => (0, io_1.f) `${p}`).join(', '), ')',
        ].join('');
        return `${targetDescription}${parameterDescriptions}`;
    }
    /**
     * Maps this question to one of a different type.
     *
     * ```ts
     * Question.about('number returned as string', actor => '42')   // returns: QuestionAdapter<string>
     *   .as(Number)                                                // returns: QuestionAdapter<number>
     * ```
     *
     * @param mapping
     */
    as(mapping) {
        return Question.about((0, io_1.f) `${this}.as(${mapping})`, async (actor) => {
            const answer = (await actor.answer(this));
            return mapping(answer);
        });
    }
}
exports.Question = Question;
/** @package */
class QuestionStatement extends Interaction_1.Interaction {
    constructor(subject, body) {
        super(subject, QuestionStatement.callerLocation(4));
        this.subject = subject;
        this.body = body;
    }
    /**
     * Returns a Question that resolves to `true` if resolving the {@apilink QuestionStatement}
     * returns a value other than `null` or `undefined`, and doesn't throw errors.
     */
    isPresent() {
        return new IsPresent((0, io_1.f) `${this}.isPresent()`, this.body);
    }
    async answeredBy(actor) {
        return this.body(actor);
    }
    async performAs(actor) {
        await this.body(actor);
    }
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
    as(mapping) {
        return Question.about((0, io_1.f) `${this}.as(${mapping})`, async (actor) => {
            const answer = await actor.answer(this);
            if (!isDefined(answer)) {
                return undefined; // eslint-disable-line unicorn/no-useless-undefined
            }
            return mapping(answer);
        });
    }
}
/**
 * @package
 */
class IsPresent extends Question {
    constructor(subject, body) {
        super();
        this.subject = subject;
        this.body = body;
    }
    async answeredBy(actor) {
        try {
            const answer = await this.body(actor);
            if (answer === undefined || answer === null) {
                return false;
            }
            if (this.isOptional(answer)) {
                return await actor.answer(answer.isPresent());
            }
            return true;
        }
        catch {
            return false;
        }
    }
    isOptional(maybeOptional) {
        return typeof maybeOptional === 'object'
            && Reflect.has(maybeOptional, 'isPresent');
    }
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
}
/**
 * @package
 */
function isDefined(value) {
    return value !== undefined
        && value !== null;
}
/**
 * @package
 */
const maxRecursiveCallsLimit = 100;
/**
 * @package
 */
async function recursivelyAnswer(actor, answerable, description, currentRecursion = 0) {
    if (currentRecursion >= maxRecursiveCallsLimit) {
        throw new errors_1.LogicError(`Question.fromObject() has reached the limit of ${maxRecursiveCallsLimit} recursive calls while trying to resolve ${description}. Could it contain cyclic references?`);
    }
    const answer = await actor.answer(answerable);
    if ((0, objects_1.isRecord)(answer)) {
        const entries = Object.entries(answer);
        const answeredEntries = [];
        for (const [key, value] of entries) {
            answeredEntries.push([key, await recursivelyAnswer(actor, value, description, currentRecursion + 1)]);
        }
        return Object.fromEntries(answeredEntries);
    }
    if (Array.isArray(answer)) {
        const answeredEntries = [];
        for (const item of answer) {
            answeredEntries.push(await recursivelyAnswer(actor, item, description, currentRecursion + 1));
        }
        return answeredEntries;
    }
    return answer;
}
//# sourceMappingURL=Question.js.map