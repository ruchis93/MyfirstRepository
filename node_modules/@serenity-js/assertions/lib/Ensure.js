"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ensure = void 0;
const core_1 = require("@serenity-js/core");
const inspected_1 = require("@serenity-js/core/lib/io/inspected");
const model_1 = require("@serenity-js/core/lib/model");
const tiny_types_1 = require("tiny-types");
/**
 * The {@apilink Interaction|interaction} to `Ensure`
 * verifies if the resolved value of the provided {@apilink Answerable}
 * meets the specified {@apilink Expectation}.
 * If not, it throws an {@apilink AssertionError}.
 *
 * Use `Ensure` to verify the state of the system under test.
 *
 * ## Basic usage with static values
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { Ensure, equals } from '@serenity-js/assertions'
 *
 * await actorCalled('Erica').attemptsTo(
 *   Ensure.that('Hello world!', equals('Hello world!'))
 * )
 * ```
 *
 * ## Composing expectations with `and`
 *
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { and, Ensure, startsWith, endsWith } from '@serenity-js/assertions'
 *
 * await actorCalled('Erica').attemptsTo(
 *   Ensure.that('Hello world!', and(startsWith('Hello'), endsWith('!'))
 * )
 * ```
 *
 * ## Overriding the type of Error thrown upon assertion failure
 *
 * ```ts
 * import { actorCalled, TestCompromisedError } from '@serenity-js/core'
 * import { and, Ensure, startsWith, endsWith } from '@serenity-js/assertions'
 * import { CallAnApi, GetRequest, LastResponse, Send } from '@serenity-js/rest'
 *
 * await actorCalled('Erica')
 *   .whoCan(CallAnApi.at('https://example.com'))
 *   .attemptsTo(
 *     Send.a(GetRequest.to('/api/health')),
 *     Ensure.that(LastResponse.status(), equals(200))
 *       .otherwiseFailWith(TestCompromisedError, 'The server is down, please cheer it up!')
 *   )
 * ```
 *
 * @group Interactions
 */
class Ensure extends core_1.Interaction {
    /**
     * @param {Answerable<Actual_Type>} actual
     *  An {@apilink Answerable} describing the actual state of the system.
     *
     * @param {Expectation<Actual_Type>} expectation
     *  An {@apilink Expectation} you expect the `actual` value to meet
     *
     * @returns {Ensure<Actual_Type>}
     */
    static that(actual, expectation) {
        return new Ensure(actual, expectation, core_1.Activity.callerLocation(5));
    }
    /**
     * @param actual
     * @param expectation
     * @param location
     */
    constructor(actual, expectation, location) {
        super((0, core_1.d) `#actor ensures that ${actual} does ${expectation}`, location);
        this.actual = actual;
        this.expectation = expectation;
    }
    /**
     * @inheritDoc
     */
    async performAs(actor) {
        const outcome = await actor.answer(this.expectation.isMetFor(this.actual));
        return (0, tiny_types_1.match)(outcome)
            .when(core_1.ExpectationNotMet, o => {
            actor.collect(this.artifactFrom(o.expected, o.actual), new model_1.Name(`Assertion Report`));
            throw this.errorForOutcome(o);
        })
            .when(core_1.ExpectationMet, _ => void 0)
            .else(o => {
            throw new core_1.LogicError((0, core_1.f) `Expectation#isMetFor(actual) should return an instance of an ExpectationOutcome, not ${o}`);
        });
    }
    /**
     * Overrides the default {@apilink AssertionError} thrown when
     * the actual value does not meet the expectation.
     *
     * @param typeOfRuntimeError
     *  A constructor function producing a subtype of {@apilink RuntimeError} to throw, e.g. {@apilink TestCompromisedError}
     *
     * @param message
     *  The message explaining the failure
     */
    otherwiseFailWith(typeOfRuntimeError, message) {
        return new EnsureOrFailWithCustomError(this.actual, this.expectation, typeOfRuntimeError, message);
    }
    /**
     * Maps an {@apilink ExpectationOutcome} to appropriate {@apilink RuntimeError}.
     */
    errorForOutcome(outcome) {
        return this.asAssertionError(outcome);
    }
    /**
     * Maps an {@apilink Outcome} to {@apilink AssertionError}.
     *
     * @param outcome
     */
    asAssertionError(outcome) {
        const actualDescription = (0, core_1.d) `${this.actual}`;
        const inspectedActual = (0, inspected_1.inspected)(outcome.actual, { inline: true, markQuestions: false });
        const message = actualDescription === inspectedActual
            ? `Expected ${actualDescription} to ${outcome.message}`
            : `Expected ${actualDescription} to ${outcome.message} but got ${inspectedActual}`;
        return new core_1.AssertionError(message, outcome.expected, outcome.actual);
    }
    artifactFrom(expected, actual) {
        return model_1.AssertionReport.fromJSON({
            expected: (0, inspected_1.inspected)(expected),
            actual: (0, inspected_1.inspected)(actual),
        });
    }
}
exports.Ensure = Ensure;
/**
 * @package
 */
class EnsureOrFailWithCustomError extends Ensure {
    constructor(actual, expectation, typeOfRuntimeError, message) {
        super(actual, expectation, core_1.Activity.callerLocation(6));
        this.typeOfRuntimeError = typeOfRuntimeError;
        this.message = message;
    }
    errorForOutcome(outcome) {
        const assertionError = this.asAssertionError(outcome);
        return new this.typeOfRuntimeError(this.message || assertionError.message, assertionError);
    }
}
//# sourceMappingURL=Ensure.js.map